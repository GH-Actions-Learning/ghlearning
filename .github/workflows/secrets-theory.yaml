What are secrets in GitHub Actions?

Secrets in GitHub Actions are encrypted environment variables that you can use to securely store sensitive data, such as:

1) API keys

2) Access tokens

3) Passwords

4) SSH private keys

5) Azure service principal credentials

6) AWS credentials

They are not visible in logs, cannot be read directly in workflows, and help prevent leaks of sensitive data.

| Feature                | Description                                                                         |
| ---------------------- | ----------------------------------------------------------------------------------- |
| Encrypted Storage      | Secrets are stored securely in GitHub and encrypted at rest.                        |
| Scoped                 | Secrets can be set at **repository**, **organization**, or **environment** levels.  |
| Read-Only in Workflows | Secrets cannot be modified in workflows — only read.                                |
| Masked in Logs         | If a secret value is echoed or accidentally printed, GitHub automatically masks it. |

🔍 Types of Secrets in GitHub Actions

| Scope                       | Use Case                                                                     |
| --------------------------- | ---------------------------------------------------------------------------- |
| 🔹 **Repository secrets**   | Most common — used by workflows in a single repository.                      |
| 🔹 **Environment secrets**  | Useful when different secrets are needed for **dev/test/prod environments**. |
| 🔹 **Organization secrets** | Shared across multiple repositories — best for consistency and governance.   |

---

🛡️ Why Are Secrets Important?

✅ Security
Secrets are encrypted at rest and masked in logs.

✅ Access Control
They can be scoped to repos, environments, or orgs.

✅ Prevent Secret Leaks
GitHub automatically hides (***) secret values in output/logs.

✅ Essential for DevOps Pipelines
Every cloud login, deployment, and notification in CI/CD depends on secrets.

---
🔑 Characteristics of GitHub Secrets

| Feature                  | Explanation                                    |
| ------------------------ | ---------------------------------------------- |
| 🔒 Encrypted             | Secrets are stored encrypted by GitHub.        |
| 🧭 Context-based access  | Available only inside workflows.               |
| 🪪 Masked                 | Secrets are masked (e.g., `***`) in logs.      |
| 🧾 Read-only             | Cannot be modified in workflows.               |
| 👀 Not visible           | You can’t echo them plainly; they won’t print. |
| 🧑‍💻 Set via UI/CLI/API | Manage via GitHub web UI, `gh` CLI, or API.    |

---
🆚 Secrets vs. Variables

| Feature        | Secrets               | GitHub Variables          |
| -------------- | --------------------- | ------------------------- |
| Encrypted      | ✅ Yes                 | ❌ No                      |
| Masked in logs | ✅ Yes                 | ❌ No                      |
| Use case       | Sensitive data        | Config/data not sensitive |
| Syntax         | `${{ secrets.NAME }}` | `${{ vars.NAME }}`        |


---
⚠️ Limitations of Secrets

| Limitation               | Description                                                       |
| ------------------------ | ----------------------------------------------------------------- |
| Max size per secret      | **48 KB** per secret                                              |
| Secrets per repository   | Up to **100** repository secrets                                  |
| Secrets per environment  | Up to **100** environment secrets                                 |
| Secrets per organization | Up to **1,000** organization secrets                              |
| Access in PRs from forks | Secrets are **not accessible** in workflows run on PRs from forks |
| Editable in workflows    | Secrets are **read-only** inside workflows                        |

---
Difference Between Environment Secrets and Repository Secrets

| Feature                           | Repository Secrets                                   | Environment Secrets                                   |
| --------------------------------- | ---------------------------------------------------- | ----------------------------------------------------- |
| 🔍 **Where Defined**              | Repo → Settings → Secrets → Actions                  | Repo → Settings → Environments → \[Env] → Secrets     |
| 🧭 **Scope**                      | Global to the whole repo’s workflows                 | Scoped to jobs that declare that specific environment |
| 🏷️ **When Available**            | Available in **any job** of any workflow in the repo | Available **only in jobs that use that environment**  |
| ✅ **Approval Support**            | ❌ No approval support                                | ✅ Supports required reviewers before execution        |
| 🔐 **Use Case**                   | Generic secrets (e.g., Docker password, tokens)      | Stage-specific secrets (e.g., prod/staging API keys)  |
| 🧠 **Access Control Granularity** | Low (global to repo)                                 | High (per-environment, per-job)                       |


---
🧠 Quick Rules to Remember

1) Secrets are not automatically inherited across scopes: 
    You must specifically define secrets at the organization, repository, or environment level where you want to use them. Even with reusable workflows, secrets are not automatically passed unless you use the secrets: inherit keyword in your workflow configuration. 
    Without that explicit configuration, secrets defined at one scope are not inherited by workflows or jobs in other scopes.

2) Lower-level secrets override higher-level secrets when names clash: 
    If a secret with the same name exists in both repository and environment scopes, the secret defined in the lower scope (e.g., environment) takes precedence when accessed in that scope.

3) Secrets are confined to the scope they’re defined in (organization, repository, or environment): 
    Secrets at each scope (organization, repository, or environment) are only available to workflows running in that scope. They aren't available by default to other scopes.

4) Secrets with the same name in different scopes are independent, but precedence is respected: 
    If secrets with the same name exist in multiple scopes, they do not share values; each must be managed separately, and GitHub uses scope precedence rules to determine which value is used in a workflow.


---
🧠 Basics: Accessing Secrets in a Workflow

You access any secret in a workflow like this:

    ${{ secrets.SECRET_NAME }}

This works:

1. Inside run: commands

2. In env: blocks

3. In with: inputs (for actions)

---

What’s Allowed and What’s Not

| Capability                                     | Allowed / Not Allowed | Notes                                                                         |
| ---------------------------------------------- | --------------------- | ----------------------------------------------------------------------------- |
| Using secrets in `env:` or `with:` in steps    | Allowed               | Standard usage — secure and masked ([GitHub Docs][1])                         |
| Referencing secrets in `if:` conditionals      | Not directly          | Must use env var workaround ([GitHub Docs][1])                                |
| Passing secrets as job outputs                 | Not allowed           | GitHub redacts such outputs ([GitHub Docs][2], [DEV Community][3])            |
| Workarounds (encrypt or encode before passing) | Allowed               | Valid patterns to securely pass values across jobs ([Medium][4], [GitHub][5]) |

---
GitHub does not mask inputs (reusable and composite workflows), 
so you must be careful to never echo secret values unless masked manually or passed through environment variables.

When passing a secret as an input to a reusable or composite workflow, that value is not automatically masked in workflow logs if it is echoed or printed, because GitHub only masks values that are registered as secrets in the workflow context—not arbitrary inputs or parameters.

This means if you echo a secret passed as an input, it will be visible in logs unless you manually register it as a secret or assign it to an environment variable derived from a secret context (such as via env: using ${{ secrets.YOUR_SECRET }}).

GitHub’s masking mechanism is tied to the values explicitly managed as secrets, not to input parameters. Multiple community threads and reference guides explicitly warn about this behavior and recommend only passing secrets using the secrets block, and never exposing them directly as inputs.

Key recommendation:

If you need to use secrets in composite or reusable workflows, always pass them through the secrets: mapping and reference them through ${{ secrets.NAME }} to keep them masked. 
If you must accept dynamic secrets as inputs, consider encoding or encrypting them as a workaround, but be cautious as they are not automatically masked unless explicitly set as secrets in the context.

---

SECRET SCOPE

| Secret Scope | Priority Rank | Overridden By |
| ------------ | ------------- | ------------- |
| Environment  | 🔝 1st        | N/A           |
| Repository   | 2nd           | Env           |
| Organization | 3rd           | Repo, Env     |

1) Environment secrets have the highest precedence and will override secrets with the same name defined at the repository or organization level when the workflow job runs in that environment context.

2) Repository secrets come next in precedence and will override organization-level secrets but can be overridden by environment secrets.

3) Organization secrets have the lowest precedence; they are shared across multiple repositories but can be overridden by repository-level or environment-level secrets of the same name.