1. ğŸ”§ What is a Matrix?

A matrix lets you define variables with multiple values so GitHub automatically creates parallel jobs for each combination (cartesian product). It massively streamlines testing across OS versions, language versions, browsers, etc. 

Basic Example

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [14, 16]
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm test

This yields 3 OS Ã— 2 Node versions = 6 jobs, all in parallel. 

------------

2. ğŸ§  Key Parameters in strategy.matrix

matrix: Defines variable sets to combine.

exclude: Removes specific unwanted combos.

include: Adds custom combos not covered by base matrix.

maxâ€‘parallel: Limits how many run concurrently.

failâ€‘fast: Default trueâ€”stops matrix if a job fails. Set to false to let all run. 

------------

Example with exclude, include, max-parallel, fail-fast:

strategy:
  fail-fast: false
  max-parallel: 5
  matrix:
    os: [ubuntu-latest, windows-latest, macos-latest]
    version: [12, 14, 16]
    browser: [chrome, firefox, safari]
    exclude:
      - os: windows-latest
        browser: safari
    include:
      - os: windows-latest
        browser: edge
        version: 18
Here:

exclude skips incompatible OS-browser pairs.

include supplements a custom Win+Edge+v18 combo.

max-parallel throttles concurrent runs.

fail-fast disabled so full feedback is generated. 

-----------

3. ğŸ› include & exclude in Depth

exclude: Prevents running undesirable combos. Even partial match excludes.

include: Can Add new jobs beyond base combos. Extend existing combos with extra variables. Apply only to matching base combos. 

Detailed example from official docs:

strategy:
  matrix:
    fruit: [apple, pear]
    animal: [cat, dog]
    include:
      - color: green
      - color: pink
        animal: cat
      - fruit: apple
        shape: circle
      - fruit: banana
      - fruit: banana
        animal: cat

This carefully constructs combos using official include logic. 

-----------

4. âš™ï¸ Advanced Matrix Use Cases

A. Single-dimension matrix

When only testing versions:

matrix:
  version: [10,12,14]
Creates one job per version. 

B. Dynamic matrix from previous job outputs

jobs:
  gen-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set.outputs.matrix }}
    steps:
      - id: set
        run: |
          echo 'matrix={"include":[{"os":"ubuntu-latest","node":"20"}]}' >> "$GITHUB_OUTPUT"

  test:
    needs: gen-matrix
    runs-on: ${{ matrix.os }}
    strategy:
      matrix: ${{ fromJSON(needs.gen-matrix.outputs.matrix) }}
    steps:
      - run: echo "Node ${{ matrix.node }}"

C. Using Strategy Context

You can access:

strategy.job-index: zero-based index of each job.

strategy.job-total: total number of jobs.

strategy.max-parallel etc. 

--------

5. âœ… Best Practices

Use fail-fast: false when you need full results matrix. 

Limit concurrency with max-parallel to manage resources. 

Use exclude to skip incompatible combos early.

Use include to add edge-case combos.

Prefer dynamic matrices if combos depend on runtime contexts.

Cap matrix size to â‰¤â€¯256 jobs. 

-----------

| Feature          | Purpose                                             |
| ---------------- | --------------------------------------------------- |
| matrix           | Define variables & their sets for job combinations  |
| exclude          | Skip invalid/unwanted combos                        |
| include          | Add custom combos or override parts of combos       |
| max-parallel     | Control concurrency                                 |
| fail-fast        | Determine whether to halt matrix on first failure   |
| dynamic matrix   | Generate matrix values based on earlier job outputs |
| strategy context | Use job-index, total, etc in run-time steps         |


---------
---------

ğŸš« Part 1: Problems & Use Cases Without include

The matrix keyword in GitHub Actions creates jobs by taking all combinations of the values you provide. However, it has limitations when you want to:

--------
--------

ğŸ”¹ Problem 1: Add a combination that isn't part of the cartesian product

Scenario: Suppose you want to test:

Node.js 16 on Ubuntu

Node.js 18 on Ubuntu

Node.js 20 only on Windows

Without include, youâ€™d need to list every combination manually, or you'd get:

Node.js 20 also on Ubuntu and Mac (which you don't want).

âŒ Without include:

strategy:
  matrix:
    os: [ubuntu-latest, windows-latest]
    node: [16, 18, 20]

â›” Output (auto-generated jobs):

ubuntu + 16 âœ…
ubuntu + 18 âœ…
ubuntu + 20 âŒ (not wanted!)
windows + 16 âœ…
windows + 18 âœ…
windows + 20 âœ…

-----------

ğŸ›‘ Problem: You get ubuntu+20, which you donâ€™t want, and no way to add custom jobs like Mac+14 if needed.

ğŸ”¹ Problem 2: Adding extra metadata for a specific combo

Sometimes you want to run a specific job with extra configurationâ€”like a flag, label, or secretâ€”based on a combo. Without include, you canâ€™t inject custom data.

âŒ Without include:

matrix:
  os: [ubuntu-latest]
  node: [16, 18]

You cannot do:

- name: Deploy to prod
  if: ${{ matrix.node == 18 && matrix.env == 'prod' }}

Because matrix.env doesn't exist.

-----------

ğŸ”¹ Problem 3: Only one value in one axis

If you only want:

Ubuntu+16

Windows+18

You canâ€™t express asymmetric combinations using only matrix.

-----------

ğŸ”¹ Problem 4: You canâ€™t dynamically inject additional matrix keys

Letâ€™s say you want:

Linux+Python3.8+label=â€œlegacyâ€

Linux+Python3.11+label=â€œmodernâ€

You canâ€™t add label without include.

-----------------

âœ… Part 2: How include Solves These Problems

The include keyword lets you manually add specific combinations, or extend existing ones with more variables.

-----------
ğŸ”¹ Problem 1: Add Custom Combo (Fixed)

Letâ€™s fix the unwanted ubuntu+20:

strategy:
  matrix:
    os: [ubuntu-latest]
    node: [16, 18]
    include:
      - os: windows-latest
        node: 20

âœ… Output (jobs created):

ubuntu + 16 âœ…
ubuntu + 18 âœ…
windows + 20 âœ… (added manually!)

Now you only run desired combos, avoiding ubuntu+20.

--------

ğŸ”¹ Problem 2: Add Metadata

strategy:
  matrix:
    os: [ubuntu-latest]
    node: [16, 18]
    include:
      - os: ubuntu-latest
        node: 18
        environment: prod
Step:

- run: echo "Env: ${{ matrix.environment }}"

âœ… Output:

Job 1: node=16 âœ Env: (nothing)
Job 2: node=18 âœ Env: prod âœ…
You can now inject matrix.environment only for node=18 jobs.

-----

ğŸ”¹ Problem 3: Asymmetric Pairs

strategy:
  matrix:
    include:
      - os: ubuntu-latest
        node: 14
      - os: windows-latest
        node: 16
      - os: macos-latest
        node: 18

âœ… This avoids any cartesian product â€” you control every job manually.

---------

ğŸ”¹ Problem 4: Add More Keys (like tags, flags)

strategy:
  matrix:
    include:
      - os: ubuntu-latest
        python: 3.8
        label: legacy
      - os: ubuntu-latest
        python: 3.11
        label: modern

Now you can use ${{ matrix.label }} to determine behavior in your steps.

- run: echo "Running ${{ matrix.label }} tests"

âœ… Output:

Running legacy tests
Running modern tests

Summary

| Problem Without `include`                   | How `include` Helps                                             |
| ------------------------------------------- | --------------------------------------------------------------- |
| Extra combinations outside cartesian matrix | Add those exact combos manually                                 |
| Need extra fields like env/flag             | Inject arbitrary matrix fields (`env`, `label`, etc.)           |
| Want asymmetric matrix                      | Avoid `matrix.os` Ã— `matrix.node`, use include instead          |
| Need conditional behavior                   | Add fields to trigger logic (`if: ${{ matrix.env == 'prod' }}`) |



---------------------
----------------------

ğŸ”´ Step 1: Problems When We Donâ€™t Use exclude

Letâ€™s identify the real-world problems you might face if you don't use exclude, along with examples.

----------

ğŸ”¹ Problem 1: Invalid or Incompatible Combinations

Example:

You want to test these combinations:

Python on Ubuntu

PowerShell on Windows

But your matrix is defined like this:

matrix:
  os: [ubuntu-latest, windows-latest]
  lang: [python, powershell]

âŒ Output Without exclude:

It creates 4 combinations:

ubuntu + python      âœ…
ubuntu + powershell  âŒ (PowerShell might fail here)
windows + python     âœ…
windows + powershell âœ…

ğŸš¨ ubuntu + powershell is invalid or unnecessary â€” it wastes resources or causes build failures.

-------------
ğŸ”¹ Problem 2: Redundant Jobs

Sometimes the full cartesian product is not needed.

Example: 

You want: Ubuntu with Node.js 14, 16

Windows only with Node.js 18

But a full matrix gives:

ubuntu + 14 âœ…
ubuntu + 16 âœ…
ubuntu + 18 âŒ (redundant)
windows + 14 âŒ (unwanted)
windows + 16 âŒ (unwanted)
windows + 18 âœ…

Without exclude, you canâ€™t stop these extras unless you rewrite everything.

---------

ğŸ”¹ Problem 3: Adding a Custom Combination with include Isnâ€™t Enough

Even if you add your desired combo using include, you still need exclude to remove the undesired ones from the base matrix.

---------

ğŸ§  How exclude Works Internally

It matches against the generated matrix from the base matrix (before include).

Only full key matches are removed.

exclude does not affect manually added combos in include.

---------

âœ… Best Practices with exclude

| âœ… **Tip**                                                     | ğŸ’¡ **Why**                                                                                    |
| ------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| Use it when using a **base matrix** to remove invalid combos  | Helps eliminate OS/tool/version pairs that are logically or technically incompatible          |
| Pair with `include` to build **perfect sets** of jobs         | Lets you define custom combos (`include`) and remove unwanted auto-generated ones (`exclude`) |
| Don't use it alone if youâ€™re defining **only include combos** | If you only use `include`, the base matrix isnâ€™t usedâ€”so `exclude` wonâ€™t do anything          |
| Be careful â€” `exclude` works on **exact matches** only        | Partial matches wonâ€™t work â€” all key-value pairs must match to be excluded successfully       |
