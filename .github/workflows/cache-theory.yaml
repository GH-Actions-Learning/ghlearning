ğŸ”¶ What is cache in GitHub Actions?

ğŸ“Œ Definition:

GitHub Actions cache is used to store dependencies or files that are reused in subsequent workflow runs â€” reducing build time and external downloads.

It prevents repeated work like downloading large packages (e.g., npm, pip, Maven, Gradle, etc.), compiling assets, or setting up tools that havenâ€™t changed.

-----------------

ğŸ§  Concept in Simple Terms

Imagine you're baking a cake and every time you make it, you need to go to the store to get flour, eggs, sugar... it's repetitive.
Instead, you keep the ingredients in your kitchen (a cache), so next time it's faster to start baking.

Same idea applies here: 

download/store things once â†’ reuse them â†’ save time â±ï¸

----------------

ğŸ§© Use Cases of Cache

| Use Case                    | Description                                    |
| --------------------------- | ---------------------------------------------- |
| `npm`, `pip`, `maven`, etc. | Speed up dependency installations              |
| Compiled build artifacts    | Reuse build steps in long compilation cycles   |
| Downloaded tools or SDKs    | e.g., Android SDK, Terraform plugins           |
| Docker layers (less common) | Advanced case for caching Docker layer folders |


âš ï¸ Where not to use Cache

| Don't Use For                         | Why                                                  |
| ------------------------------------- | ---------------------------------------------------- |
| Frequently changing files             | Cache won't hit; adds overhead                       |
| Secrets or sensitive data             | Never store secrets in cache                         |
| Large artifacts better in `artifacts` | Use `upload-artifact` for passing files between jobs |


âœ… Required and Optional Parameters for actions/cache@v4

| Parameter              | Required? | Description                                                              |
| ---------------------- | --------- | ------------------------------------------------------------------------ |
| `path`                 | âœ… Yes     | Path(s) to cache (can be a single string or a list of paths)             |
| `key`                  | âœ… Yes     | Unique key to identify the cache                                         |
| `restore-keys`         | âŒ No      | Fallback keys used when `key` doesnâ€™t match                              |
| `enableCrossOsArchive` | âŒ No      | Allows caches to be restored across different OS types (Linux â†” Windows) |
| `lookup-only`          | âŒ No      | If `true`, only checks if cache exists (doesnâ€™t restore or save)         |
| `upload-chunk-size`    | âŒ No      | Breaks cache uploads into smaller chunks (in bytes) to avoid timeout     |

ğŸ” Cross-Job Caching vs Artifacts

| Feature | Cache                       | Artifacts                     |
| ------- | --------------------------- | ----------------------------- |
| Purpose | Reuse between workflow runs | Pass files between jobs/steps |
| Speed   | Faster (pre-job step)       | Slower (upload/download)      |
| Expiry  | Automatically evicted       | Stored for limited days (90d) |
| Example | Reuse node\_modules         | Share test results, coverage  |


âœ… Best Practices

Use hashFiles() on lock files (package-lock.json, poetry.lock, etc.)

Cache folders that are safe to reuse (e.g., ~/.npm, ~/.m2, .gradle, etc.)

Keep cache size small â€” GitHub has a 5GB limit per cache

Do not cache temporary build output unless reused across jobs

Use restore-keys wisely â€” donâ€™t make them too generic, or wrong cache could be used


----------------------------------------------
----------------------------------------------

ğŸŸ¢ What Is a Static Cache Key?

ğŸ“Œ Definition:

A static cache key is a fixed string used as the key parameter in actions/cache.
This means that the cache never changes unless you manually update the key.

ğŸ“Œ Behavior:

If a cache with that key exists, it will be restored.

If the key does not exist, a new cache is created and saved under that static name.

ğŸ“Œ Characteristics of Static Keys

| Feature               | Description                                                              |
| --------------------- | ------------------------------------------------------------------------ |
| ğŸ” Reusability        | Always reuses the same cache if it exists                                |
| âŒ No Invalidation     | Cache **does not change** even if dependencies (e.g., `package.json`) do |
| âœ… Simple Setup        | Great for learning, demos, or rarely changing dependencies               |
| âš ï¸ Dangerous for Prod | Can result in **stale dependencies** if packages change                  |


ğŸ§  When Should You Use Static Cache Keys?

| âœ… Use When                 | âŒ Avoid When                                               |
| -------------------------- | ---------------------------------------------------------- |
| Learning / experimenting   | In production pipelines                                    |
| Dependencies rarely change | Your build depends on lockfiles (like `package-lock.json`) |
| Fast prototyping           | Your workflow must adapt to file changes                   |


ğŸ” Static Key Best Practices

| Tip                                     | Why It Matters                                          |
| --------------------------------------- | ------------------------------------------------------- |
| Name key clearly (e.g., `npm-cache-v1`) | Helps version or track usage manually                   |
| Add `v1`, `v2`, etc. manually           | Lets you forcefully invalidate cache by editing the key |
| Use for quick feedback / dev jobs       | Saves time without complex setup                        |
| **Donâ€™t use in critical prod CI/CD**    | Can introduce bugs due to stale data                    |


âš ï¸ Pitfall: What if dependencies change?

If someone changes package-lock.json or a new package is added, and you're using a static key:

The cache is still restored

The build might fail or install wrong versions

You won't know cache is outdated

ğŸ“Œ Summary: GitHub Cache Internals (Static Key)

| Internals                           | Description                                          |
| ----------------------------------- | ---------------------------------------------------- |
| Cache stored in Azure blob          | Managed, compressed, scoped per repo/branch/workflow |
| Restored pre-job, saved post-job    | Happens automatically by GitHub infrastructure       |
| Static keys never change            | Must be manually updated to refresh cache            |
| Eviction after 7 days of inactivity | Or if repo exceeds quota or branch is deleted        |
| Cannot be overwritten               | GitHub does not allow overwriting the same key       |

â³ Expiry and Eviction Policy

GitHub automatically removes caches if:

| Condition                          | Details                                                             |
| ---------------------------------- | ------------------------------------------------------------------- |
| ğŸ•’ *Not accessed in 7 days*        | GitHub **automatically evicts** cache entries older than 7 days     |
| ğŸ“¦ *Repo total cache size > 10â€¯GB* | Cache storage capped at **10â€¯GB per repository**                    |
| ğŸ“‰ *Repo cache limit exceeded*     | Oldest caches are evicted first to maintain size â‰¤â€¯10â€¯GB            |
| ğŸ§ª *Branch deleted*                | **Not guaranteed by GitHub**â€”branch-scoped caches may still persist |

-------------------------------------------------
-------------------------------------------------

ğŸ” Dynamic Cache Keys in GitHub Actions

-------------------------------------------------

ğŸ”¶ What Is a Dynamic Cache Key?

A dynamic cache key is a cache key that changes automatically when certain files or inputs change â€” usually by using hashFiles() or workflow variables.

ğŸ§  Why Use Dynamic Keys?

With static keys, the cache never changes unless you manually change the key (â†’ risk of stale data).

With dynamic keys, the cache invalidates and refreshes automatically whenever your dependencies change.

âœ… Use Cases for Dynamic Keys

| Use Case             | Why Dynamic?                                                              |
| -------------------- | ------------------------------------------------------------------------- |
| Caching dependencies | Auto-refresh when `package-lock.json`, `poetry.lock`, etc. change         |
| Caching build output | React/Vue/Angular: recompile only if `src/` or `webpack.config.js` change |
| Caching test tools   | Invalidate if `.eslintrc.js`, `.prettierrc` change                        |


ğŸ’¡ Best Practices for Dynamic Cache Keys

| Tip                                    | Why It Helps                                                                    |
| -------------------------------------- | ------------------------------------------------------------------------------- |
| Use `hashFiles()` on lock/config files | Guarantees meaningful invalidation                                              |
| Add `runner.os` or `matrix.os`         | Prevents cross-platform cache corruption                                        |
| Always add `restore-keys`              | Enables fallback to similar caches when hash doesnâ€™t match                      |
| Keep paths small and relevant          | Avoid unnecessary invalidation and slow uploads                                 |
| Version your prefix                    | E.g., `v1-npm-${{ hashFiles(...) }}` â†’ lets you force invalidate manually later |


